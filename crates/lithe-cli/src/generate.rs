use anyhow::{Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;

#[derive(Debug)]
pub struct PageRoute {
    pub route: String,
    pub module_name: String,
    pub file_path: String,
    pub name: String,
}

pub fn discover_pages(project_dir: &Path) -> Result<Vec<PageRoute>> {
    let pages_dir = project_dir.join("src/pages");
    let mut pages = Vec::new();
    if !pages_dir.exists() {
        return Ok(pages);
    }

    let page_re = Regex::new(r#"#\[(?:[\w:]+::)?page\]"#).unwrap();

    for entry in fs::read_dir(&pages_dir).context("Failed to read src/pages directory")? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |ext| ext == "rs") {
            let file_stem = path.file_stem().unwrap().to_str().unwrap().to_string();
            if file_stem == "mod" {
                continue;
            }

            let content = fs::read_to_string(&path).unwrap_or_default();
            if !page_re.is_match(&content) {
                continue;
            }

            let route = if file_stem == "index" {
                "/".to_string()
            } else {
                format!("/{}", file_stem.replace('_', "-"))
            };
            let module_name = format!("{}_page", file_stem.replace('-', "_"));
            let relative_path = format!("../src/pages/{}.rs", file_stem);

            pages.push(PageRoute {
                route,
                module_name,
                file_path: relative_path,
                name: file_stem,
            });
        }
    }
    pages.sort_by(|a, b| {
        if a.route == "/" {
            std::cmp::Ordering::Less
        } else if b.route == "/" {
            std::cmp::Ordering::Greater
        } else {
            a.route.cmp(&b.route)
        }
    });
    Ok(pages)
}

pub fn generate_routes_content(pages: &[PageRoute], project_name: &str) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n");
    output.push_str("use lithe::render_page;\n\n");
    for page in pages {
        output.push_str(&format!("#[path = \"{}\"]\n", page.file_path));
        output.push_str(&format!("mod {};\n", page.module_name));
    }
    output.push_str("\npub fn dispatch(path: &str) -> String {\n");
    output.push_str("    match path {\n");
    for page in pages {
        output.push_str(&format!(
            "        \"{}\" => render_page({}::page(), \"{}\"),\n",
            page.route,
            page.module_name,
            project_name.replace('-', "_")
        ));
    }
    output.push_str("        _ => \"404 Not Found\".to_string(),\n");
    output.push_str("    }\n");
    output.push_str("}\n");
    output.push_str("\npub fn routes() -> Vec<&'static str> {\n");
    output.push_str("    vec![");
    let routes: Vec<String> = pages.iter().map(|p| format!("\"{}\"", p.route)).collect();
    output.push_str(&routes.join(", "));
    output.push_str("]\n");
    output.push_str("}\n");
    output
}

pub fn generate_main_content(port: u16) -> String {
    format!(
        r#"// Auto-generated by lithe-cli - do not edit manually
use axum::{{Router, extract::Path, response::Html, routing::get}};
use tower_http::services::ServeDir;
#[path = "routes.rs"]
mod routes;
async fn handle_root() -> Html<String> {{
    Html(routes::dispatch("/"))
}}
async fn handle_path(Path(path): Path<String>) -> Html<String> {{
    Html(routes::dispatch(&format!("/{{}}", path)))
}}
#[tokio::main]
async fn main() {{
    let app = Router::new()
        .nest_service("/public", ServeDir::new(".lithe/public"))
        .route("/", get(handle_root))
        .route("/*path", get(handle_path));
    let listener = tokio::net::TcpListener::bind("0.0.0.0:{port}").await.unwrap();
    println!("Listening on http://localhost:{port}");
    axum::serve(listener, app).await.unwrap();
}}
"#,
        port = port
    )
}

pub fn discover_modules(project_dir: &Path) -> Result<Vec<(String, String)>> {
    let src_dir = project_dir.join("src");
    let mut modules = Vec::new();
    if !src_dir.exists() {
        return Ok(modules);
    }
    for entry in fs::read_dir(&src_dir).context("Failed to read src directory")? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
            let file_stem = path.file_stem().unwrap().to_str().unwrap().to_string();
            if file_stem == "lib" || file_stem == "main" {
                continue;
            }
            modules.push((file_stem.clone(), format!("../src/{}.rs", file_stem)));
        }
    }
    Ok(modules)
}

pub fn generate_lib_rs_content(pages: &[PageRoute], modules: &[(String, String)]) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n\n");

    for (name, path) in modules {
        output.push_str(&format!("#[path = \"{}\"]\n", path));
        output.push_str(&format!("pub mod {};\n\n", name));
    }

    for page in pages {
        output.push_str(&format!("#[path = \"{}\"]\n", page.file_path));
        output.push_str(&format!("pub mod {};\n\n", page.module_name));
    }

    output.push_str("pub mod pages {\n");
    for page in pages {
        output.push_str(&format!(
            "    pub use super::{} as {};\n",
            page.module_name, page.name
        ));
    }
    output.push_str("}\n\n");

    output.push_str("#[cfg(target_arch = \"wasm32\")]\n");
    output.push_str("#[path = \"wasm_exports.rs\"]\n");
    output.push_str("mod wasm_exports;\n");

    output
}

pub fn generate_all(project_dir: &Path, port: u16) -> Result<()> {
    let lithe_dir = project_dir.join(".lithe");
    fs::create_dir_all(&lithe_dir).context("Failed to create .lithe directory")?;
    let cargo_toml_path = project_dir.join("Cargo.toml");
    let cargo_toml_content = fs::read_to_string(&cargo_toml_path)?;
    let project_name = cargo_toml_content
        .lines()
        .find(|l| l.starts_with("name = "))
        .map(|l| l.split('=').nth(1).unwrap().trim().trim_matches('"'))
        .unwrap_or("app");
    let pages = discover_pages(project_dir)?;
    let modules = discover_modules(project_dir)?;

    let routes_content = generate_routes_content(&pages, project_name);
    fs::write(lithe_dir.join("routes.rs"), routes_content)
        .context("Failed to write .lithe/routes.rs")?;

    let main_content = generate_main_content(port);
    fs::write(lithe_dir.join("main.rs"), main_content).context("Failed to write .lithe/main.rs")?;

    let lib_content = generate_lib_rs_content(&pages, &modules);
    fs::write(lithe_dir.join("lib.rs"), lib_content).context("Failed to write .lithe/lib.rs")?;

    Ok(())
}
