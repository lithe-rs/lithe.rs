use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

#[derive(Debug)]
pub struct PageRoute {
    pub route: String,
    pub module_name: String,
    pub file_path: String,
}

pub fn discover_pages(project_dir: &Path) -> Result<Vec<PageRoute>> {
    let pages_dir = project_dir.join("src/pages");
    let mut pages = Vec::new();

    if !pages_dir.exists() {
        return Ok(pages);
    }

    for entry in fs::read_dir(&pages_dir).context("Failed to read src/pages directory")? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().map_or(false, |ext| ext == "rs") {
            let file_stem = path.file_stem().unwrap().to_str().unwrap().to_string();

            let route = if file_stem == "index" {
                "/".to_string()
            } else {
                format!("/{}", file_stem.replace('_', "-"))
            };

            let module_name = format!("{}_page", file_stem.replace('-', "_"));

            let relative_path = format!("../src/pages/{}.rs", file_stem);

            pages.push(PageRoute {
                route,
                module_name,
                file_path: relative_path,
            });
        }
    }

    pages.sort_by(|a, b| {
        if a.route == "/" {
            std::cmp::Ordering::Less
        } else if b.route == "/" {
            std::cmp::Ordering::Greater
        } else {
            a.route.cmp(&b.route)
        }
    });

    Ok(pages)
}

pub fn generate_routes_content(pages: &[PageRoute]) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n");
    output.push_str("use lithe::render_to_string;\n\n");

    for page in pages {
        output.push_str(&format!("#[path = \"{}\"]\n", page.file_path));
        output.push_str(&format!("mod {};\n", page.module_name));
    }

    output.push_str("\npub fn dispatch(path: &str) -> String {\n");
    output.push_str("    match path {\n");
    for page in pages {
        output.push_str(&format!(
            "        \"{}\" => render_to_string(&{}::page()),\n",
            page.route, page.module_name
        ));
    }
    output.push_str("        _ => \"404 Not Found\".to_string(),\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output.push_str("\npub fn routes() -> Vec<&'static str> {\n");
    output.push_str("    vec![");
    let routes: Vec<String> = pages.iter().map(|p| format!("\"{}\"", p.route)).collect();
    output.push_str(&routes.join(", "));
    output.push_str("]\n");
    output.push_str("}\n");

    output
}

pub fn generate_main_content(port: u16) -> String {
    format!(
        r#"// Auto-generated by lithe-cli - do not edit manually
use axum::{{Router, extract::Path, response::Html, routing::get}};

#[path = "routes.rs"]
mod routes;

async fn handle_root() -> Html<String> {{
    Html(routes::dispatch("/"))
}}

async fn handle_path(Path(path): Path<String>) -> Html<String> {{
    Html(routes::dispatch(&format!("/{{}}", path)))
}}

#[tokio::main]
async fn main() {{
    let app = Router::new()
        .route("/", get(handle_root))
        .route("/*path", get(handle_path));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:{port}").await.unwrap();
    println!("Listening on http://localhost:{port}");
    axum::serve(listener, app).await.unwrap();
}}
"#,
        port = port
    )
}

pub fn generate_all(project_dir: &Path, port: u16) -> Result<()> {
    let lithe_dir = project_dir.join(".lithe");
    fs::create_dir_all(&lithe_dir).context("Failed to create .lithe directory")?;

    let pages = discover_pages(project_dir)?;
    let routes_content = generate_routes_content(&pages);
    fs::write(lithe_dir.join("routes.rs"), routes_content)
        .context("Failed to write .lithe/routes.rs")?;

    let main_content = generate_main_content(port);
    fs::write(lithe_dir.join("main.rs"), main_content).context("Failed to write .lithe/main.rs")?;

    Ok(())
}
