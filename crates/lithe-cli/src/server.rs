use anyhow::{Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone)]
pub struct ServerFunction {
    pub full_path: String,
    pub fn_name: String,
    pub args_type: String,
}

pub fn discover_server_functions(project_dir: &Path) -> Result<Vec<ServerFunction>> {
    let src_dir = project_dir.join("src");
    let mut functions = Vec::new();
    if !src_dir.exists() {
        return Ok(functions);
    }
    scan_directory(&src_dir, &src_dir, &mut functions)?;
    Ok(functions)
}

fn scan_directory(dir: &Path, src_root: &Path, functions: &mut Vec<ServerFunction>) -> Result<()> {
    for entry in fs::read_dir(dir).context(format!("Failed to read directory: {:?}", dir))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            scan_directory(&path, src_root, functions)?;
        } else if path.extension().map_or(false, |ext| ext == "rs") {
            scan_file(&path, src_root, functions)?;
        }
    }
    Ok(())
}

fn scan_file(file_path: &Path, src_root: &Path, functions: &mut Vec<ServerFunction>) -> Result<()> {
    let content =
        fs::read_to_string(file_path).context(format!("Failed to read file: {:?}", file_path))?;

    // Regex for #[server] or #[lithe::server]
    let re = Regex::new(
        r#"#\[(?:[\w:]+::)?server\]\s*(?:pub(?:\([^)]+\))?\s+)?async\s+fn\s+(\w+)\s*\(([^)]*)\)"#,
    )
    .context("Failed to compile regex")?;

    let relative = file_path
        .strip_prefix(src_root)
        .context("File not under src root")?;
    let module_path = relative
        .with_extension("")
        .to_string_lossy()
        .replace(['/', '\\'], "::");

    for cap in re.captures_iter(&content) {
        let fn_name = cap[1].to_string();
        let args_raw = &cap[2];

        let mut arg_types = Vec::new();
        for arg in args_raw.split(',') {
            let arg = arg.trim();
            if arg.is_empty() {
                continue;
            }
            if let Some(pos) = arg.find(':') {
                arg_types.push(arg[pos + 1..].trim().to_string());
            }
        }

        let args_type = if arg_types.is_empty() {
            "()".to_string()
        } else if arg_types.len() == 1 {
            arg_types[0].clone()
        } else {
            format!("({})", arg_types.join(", "))
        };

        let full_path = format!("{}::{}", module_path, fn_name);
        functions.push(ServerFunction {
            full_path,
            fn_name,
            args_type,
        });
    }
    Ok(())
}

pub fn generate_rpc_dispatcher(
    project_dir: &Path,
    project_name: &str,
    functions: &[ServerFunction],
) -> Result<()> {
    let lithe_dir = project_dir.join(".lithe");
    let mut output = String::new();
    let crate_name = project_name.replace('-', "_");

    output.push_str("// Auto-generated by lithe-cli - do not edit manually\n");
    output.push_str("use axum::{Json, response::IntoResponse, http::StatusCode};\n");
    output.push_str("use lithe::rpc::{RpcRequest, RpcResponse};\n\n");

    output
        .push_str("pub async fn handle_rpc(Json(req): Json<RpcRequest>) -> impl IntoResponse {\n");
    output.push_str("    let result = match req.function.as_str() {\n");

    for func in functions {
        let js_name = func.full_path.replace("::", "_");
        let internal_fn = format!("__lithe_rpc_{}", func.fn_name);

        output.push_str(&format!(
            "        \"{}\" | \"{}\" => {{\n",
            func.fn_name, js_name
        ));
        output.push_str(&format!(
            "            let args: {} = serde_json::from_value(req.args).unwrap();\n",
            func.args_type
        ));

        let mod_path = func
            .full_path
            .strip_suffix(&func.fn_name)
            .unwrap()
            .trim_end_matches("::");

        output.push_str(&format!(
            "            {}::{}::{}(args).await\n",
            crate_name, mod_path, internal_fn
        ));
        output.push_str("        }\n");
    }

    output.push_str(
        "        _ => return (StatusCode::NOT_FOUND, \"Function not found\").into_response(),\n",
    );
    output.push_str("    };\n\n");

    output.push_str("    Json(RpcResponse { result }).into_response()\n");
    output.push_str("}\n");

    fs::write(lithe_dir.join("rpc.rs"), output).context("Failed to write .lithe/rpc.rs")?;
    Ok(())
}
